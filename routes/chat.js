// Generated by CoffeeScript 1.3.3
var HttpRequester, TokenManager, TranslationManager, cheerio, http, https, querystring,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

cheerio = require('cheerio');

http = require('http');

https = require('https');

querystring = require('querystring');

exports.users = {};

exports.messages = [];

exports.login = [
  {
    lang: 'ja',
    value: 'がログインしました'
  }, {
    lang: 'en',
    value: ' is logged in'
  }, {
    lang: 'zh-CHS',
    value: '登录'
  }
];

exports.logout = [
  {
    lang: 'ja',
    value: 'がログアウトしました'
  }, {
    lang: 'en',
    value: ' is logged out'
  }, {
    lang: 'zh-CHS',
    value: '注销'
  }
];

exports.accessToken = null;

exports.chat = function(client) {
  var io, messages, users;
  users = exports.users;
  messages = exports.messages;
  io = exports.io;
  console.log(client.sessionId + ' is connected.');
  client.on('login', function(user) {
    var key, l, login, msgs;
    console.log(users);
    users[user] = user;
    client.user = user;
    io.sockets.emit('updateLoginUsers', users);
    msgs = [];
    login = exports.login;
    for (l in login) {
      msgs.push({
        lang: login[l]['lang'],
        value: client.user + login[l]['value']
      });
    }
    console.log('login. past messages => ');
    for (key in messages) {
      console.log(messages[key]);
      client.emit('res', messages[key]['user'], messages[key]['msgs']);
    }
    messages.push({
      'user': 'system',
      'msgs': msgs
    });
    return io.sockets.emit('res', 'system', msgs);
  });
  client.on('chat', function(from, msg, from_lang) {
    var translationManager;
    console.log("message received. (from = " + from + ", msg = " + msg + ", from_lang=" + from_lang + ")");
    translationManager = new TranslationManager(msg, from_lang, function(results) {
      results.push({
        lang: from_lang,
        value: msg
      });
      console.log(results);
      messages.push;
      ({
        'user': from,
        'msgs': results
      });
      return io.sockets.emit('res', from, results);
    });
    return translationManager.run();
  });
  return client.on('disconnect', function() {
    var l, logout, msgs;
    console.log("" + client.sessionId + " is disconnected.");
    delete users[client.user];
    io.sockets.emit('updateLoginUsers', users);
    msgs = [];
    logout = exports.logout;
    for (l in logout) {
      msgs.push({
        lang: logout[l]['lang'],
        value: client.user + logout[l]['value']
      });
    }
    io.sockets.emit('res', 'system', msgs);
    return messages.push({
      'user': 'system',
      'msg': msgs
    });
  });
};

TranslationManager = (function() {

  function TranslationManager(orgMsg, from, callerCallback) {
    this.orgMsg = orgMsg;
    this.from = from;
    this.callerCallback = callerCallback;
    this.callback = __bind(this.callback, this);

    this.run = __bind(this.run, this);

  }

  TranslationManager.prototype.to = [];

  TranslationManager.prototype.results = [];

  TranslationManager.prototype.run = function() {
    var httpRequester, t, _i, _len, _ref, _to;
    this.to = ['ja', 'en', 'zh-CHS'];
    _to = [];
    _ref = this.to;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      t = _ref[_i];
      console.log('t => ' + t + '@from =>' + this.from);
      if (t !== this.from) {
        _to.push(t);
      }
    }
    this.to = _to;
    this.results = [];
    httpRequester = new HttpRequester(this.orgMsg, this.from, this.callback);
    return httpRequester.run(this.to[0]);
  };

  TranslationManager.prototype.callback = function(result) {
    var httpRequester;
    this.results.push(result);
    if (this.results.length >= this.to.length) {
      return this.callerCallback(this.results);
    } else {
      httpRequester = new HttpRequester(this.orgMsg, this.from, this.callback);
      return httpRequester.run(this.to[this.results.length]);
    }
  };

  return TranslationManager;

})();

HttpRequester = (function() {

  function HttpRequester(orgMsg, from, callerCallback) {
    this.orgMsg = orgMsg;
    this.from = from;
    this.callerCallback = callerCallback;
    this.callback = __bind(this.callback, this);

    this.run = __bind(this.run, this);

  }

  HttpRequester.prototype.host = "api.microsofttranslator.com";

  HttpRequester.prototype.path = "/v2/Http.svc/Translate";

  HttpRequester.prototype.to = null;

  HttpRequester.prototype.run = function(to) {
    var tokenManager;
    this.to = to;
    tokenManager = new TokenManager(this.callback);
    return tokenManager.run();
  };

  HttpRequester.prototype.callback = function(token) {
    var options, param, req, that;
    param = querystring.stringify({
      text: this.orgMsg,
      to: this.to,
      from: this.from
    });
    options = {
      host: this.host,
      path: this.path + ("?" + param),
      port: 80,
      method: 'GET',
      headers: {
        "Authorization": "Bearer " + token,
        "Content-Type": "text/xml"
      }
    };
    that = this;
    req = http.request(options, function(res) {
      res.setEncoding('utf8');
      return res.on('data', function(data) {
        var obj, result;
        obj = cheerio.load(data, {
          ignoreWhitespace: true,
          xmlMode: true
        });
        result = {
          lang: that.to,
          value: obj._root.children[0].children[0].data
        };
        return that.callerCallback(result);
      });
    });
    return req.end();
  };

  return HttpRequester;

})();

TokenManager = (function() {

  function TokenManager(callerCallback) {
    this.callerCallback = callerCallback;
    this.run = __bind(this.run, this);

  }

  TokenManager.prototype.clientId = "junchang_test";

  TokenManager.prototype.clientSecret = "et8V20k1R+bBsD23THH3q9mnhikL0jTFj1BEmUBr+9E=";

  TokenManager.prototype.host = "datamarket.accesscontrol.windows.net";

  TokenManager.prototype.path = "/v2/OAuth2-13/";

  TokenManager.prototype.scope = "http://api.microsofttranslator.com";

  TokenManager.prototype.grantType = "client_credentials";

  TokenManager.prototype.run = function() {
    var options, param, req, that, token;
    token = exports.accessToken;
    if (token && token.expires > parseInt(new Date() / 1000)) {
      return this.callerCallback(token.value);
    }
    param = querystring.stringify({
      grant_type: this.grantType,
      scope: this.scope,
      client_id: this.clientId,
      client_secret: this.clientSecret
    });
    options = {
      host: this.host,
      path: this.path,
      port: 443,
      method: 'POST'
    };
    that = this;
    req = https.request(options, function(res) {
      res.setEncoding('utf8');
      return res.on('data', function(data) {
        var obj;
        obj = JSON.parse(data);
        exports.accessToken = {
          value: obj.access_token,
          expires: parseInt(new Date() / 1000) + parseInt(obj.expires_in)
        };
        return that.callerCallback(exports.accessToken.value);
      });
    });
    req.write(param);
    return req.end();
  };

  return TokenManager;

})();
